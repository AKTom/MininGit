\input texinfo                @c -*- Texinfo -*-
@c %**start of header

@setfilename cvsanaly.texi
@include version.texi


@settitle GNU @code{CVSAnalY}
@setchapternewpage odd
@c Combine the variable and function indices:
@syncodeindex vr fn
@c Combine the program and concept indices:
@syncodeindex pg cp
@c %**end of header

@copying
This file documents the @code{CVSAnalY} tool, which extracts information
out of source code repository logs and stores it into a database. 

This is Edition @value{EDITION}, last updated @value{UPDATED},
of @cite{The CVSAnalY Manual}, for @code{CVSAnalY} version
@value{VERSION}.

Copyright @copyright{} 2009
LibreSoft

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections.
@end quotation
@end copying

@iftex
@shorttitlepage CVSAnalY
@end iftex
@titlepage
@title CVSAnalY
@subtitle A tool to analyze software repositories.
@subtitle @code{CVSAnalY} Version @value{VERSION}
@subtitle @value{UPDATED-MONTH}
@author Carlos Garcia Campos
@page
@vskip 0pt plus 1filll
@insertcopying
@sp 2
Published by LibreSoft
@end titlepage

@summarycontents
@contents

@ifnottex
@node Top, Overview, (dir), (dir)
@top @code{CVSAnalY}

@insertcopying
@end ifnottex

@menu
* Overview::                        Overview of @code{CVSAnalY}.
* Installation::                    How to install @code{CVSAnalY}.
* Usage::                           Running @code{CVSAnalY}.
* The configuration file::          The @code{CVSAnalY} configuration file.
* Database::                        The Database design.
* Extensions::                      @code{CVSAnalY} extensions. 
* FAQ::                             Frequently Asked Questions.
* GNU Free Documentation License::  License for copying this manual.

@detailmenu

The Database design

* Database Overview::               Database schema overview.
* Database schema details::         @code{CVSAnalY} database schema details.
* Extensions schema::               @code{CVSAnalY} extensions schema details.

@end detailmenu
@end menu

@node Overview, Installation, Top, Top
@comment  node-name,  next,  previous,  up
@chapter Overview of @code{CVSAnalY}

The @code{CVSAnalY} tool extracts information out of source code
repository logs and stores it into a database.

@node Installation, Usage, Overview, Top
@chapter How to install @code{CVSAnalY}

@code{CVSAnaly} uses the standard Python Distutils. First of all you
should install all the dependencies. 

@itemize @bullet

@item 
Python MySQLDB: there should be packages for your operating system, so
you should be able to install it as any other software. In Debian
systems the package is @code{python-mysqldb}

@example
@group
# apt-get install python-mysqldb
@end group
@end example

@item
Repository Handler: it's, like @code{CVSAnalY}, part of the LibreSoft
tools
set@footnote{@url{https://forge.morfeo-project.org/projects/libresoft-tools/}}. 
You will probably have to install it from sources. Here is an example
assuming Repository Hanlder 0.2 is used and the tarball has been already
downloaded.

@example
@group
$ tar xvjf repositoryhandler-0.2.tar.bz2
$ cd repositoryhandler-0.2
$ ./configure
$ make
# make install
@end group
@end example

@item 
Python SQLiteDB: it's optional, required only to use SQLite instead
MySQL as database system. It's also usually available in most of the
operating systems. 

@item
Other dependencies (CVS, SVN and Git) are actually optional, although
required depending on the type of repository you want to analyze. It's
recommended to install of them. 

@end itemize

We are now ready to install @code{CVSAnalY}.

@example
@group
$ tar xvzf cvsanaly2-@value{VERSION}.tar.gz
$ cd cvsanaly2-@value{VERSION}
# python setup.py install
@end group
@end example

You can also use @code{CVSAnalY} without installing it, just by running
the @code{cvsanaly} command from the directory sources. 

@example
@group
$ cd cvsanaly2-@value{VERSION}
$ ./cvsanaly2 --help
@end group
@end example

@node Usage, The configuration file, Installation, Top
@chapter Running @code{CVSAnalY}

Once @code{CVSAnalY} is installed you can use it just by running the
executable @command{cvsanaly2}@footnote{It's called cvsanaly2 to avoid conflicts 
with old (incompatible) cvsanaly 1.x)}

@noindent
The syntax to run @command{cvsanaly2} is the following:

@example
cvsanaly2 [options] [URI]
@end example

@noindent
Analyze the given URI. An URI can be a checked out local path directory, 
or a remote URL pointing to a repository. If URI is omitted,
the current working directory will be used as a checked out
directory. The type of the repository will be automatically detected, so
the only information you have to provide about the repository is this 
URI. @code{CVSAnalY} doesn't run checkouts, so if the repository doesn't
support remote retrieving of the log, a checked out directory must be
provided.
The repository log will be parsed and stored in a
database. @code{CVSAnalY} doesn't expect to have all privileges on the
database server, so the database should be created before running
@code{CVSAnalY} or it will fail. This is not relevant if you are using
SQLite since there isn't any server. 

@noindent
Global options:

@itemize @bullet
@item 
-h, --help

Show help information

@item 
-V, --version

Show the version number of @code{CVSAnalY}

@item
-g, --debug

Enable debug mode. It shows useful information for debugging like
the commands that are being executed, the SQL statements, parsing status
and so on. 

@item
-q, --quiet

Run silently, only important error messages is printed. 

@item
--profile

Enable profiling mode. It shows information about how long some tasks
take to run. 

@item
-f, --config-file

Use a custom configuration file. @xref{The configuration file}

@item
-l, --repo-logfile

Use the given log file as the input of the log parser instead of running
the log command for the repository. 

@item
-s, --save-logfile

Save the input log information to the given path.

@item
-n, --no-parse

Skip the parsing process. It only makes sense in conjunction with
--extensions

@item
--extensions

Run the given extensions after the log parsing/storing process. It
expects a comma-separated list with the name of the extensions to
run. Dependencies among extensions are automatically resolved by
@code{CVSAnalY}.

@end itemize

@noindent
Database specific options:

@itemize @bullet
@item
--db-driver

Use the given database system. MySQL (actually @code{mysql}) is the default
(and recommended) option.

@item
-u, --db-user

The name of the user to connect to the database system. The given user
should exist, since @code{CVSAnalY} will not try to create any
user. This option doesn't make sense if you are using SQLite. The
default option is @code{operator}. 

@item
-p, --db-password

The user's password to connect to the database system. If it's not
provided, you will be prompted to enter it. 

@item
-d, --db-database

The name of the database. I should exist, since @code{CVSAnalY} will not
try to create any database. If you are using SQLite, this option might
be a local path instead of just a name. Default option is
@code{cvsanaly}.

@item
-H, --db-hostname

The host name where database system is running. This option doesn't make
sense when using SQLite. Default option is @code{localhost}.
@end itemize

@noindent 
Examples:

@itemize @bullet

@item
Running @code{CVSAnalY} with a CVS repository already checked out using
MySQL driver.

@example
@group
$ cvsanaly2 -u carlos -d gstreamer ~/src/cvs/gstreamer
@end group
@end example

@item
Running @code{CVSAnalY} with a SVN repository using the remote URI and
SQLite as the database driver


@example
@group
$ cvsanaly2 --db-driver sqlite -d ~/db/nautilus.db \
http://svn.gnome.org/svn/nautilus
@end group
@end example

@end itemize

@node The configuration file, Database, Usage, Top
@chapter The @code{CVSAnalY} configuration file

@node Database, FAQ, The configuration file, Top
@chapter The Database design

@menu
* Database Overview::               Database schema overview.
* Database schema details::         @code{CVSAnalY} database schema details.
* Extensions schema::               @code{CVSAnalY} extensions schema details.
@end menu

@node Database Overview, Database schema details, Database, Database
@section Database schema overview

The database is divided into two main parts. The first one consists on the
set of tables that represents the history of the project based on the
information from the repository log. These tables are filled by
@code{CVSAnalY} during the parsing process exclusively with the
information provided by the repository log. This is the main goal of
@code{CVSAnalY} and, therefore, these tables will always be present in
the schema independently of how @code{CVSAnalY} was executed or even
what project has been analyzed. The second part is composed by tables
created and filled by @code{CVSAnalY} extensions
(@xref{Extensions}). The information provided by these tables depends on
every @code{CVSAnalY} Extension, however the main goal is common: to
complete the @code{CVSAnalY} schema with additional information directly
related to the existing tables but not provided by the repository log. 

TODO: screenshot

@subsection General conventions

The database has been designed according to the following rules:

@itemize @bullet

@item
Internal identifier: every table has an internal identifier called
@code{id}. It's an auto-incremental integer and it's always the primary key of
the table.

@item
Foreign keys: all fields with the suffix @code{_id} are foreign keys so
that it's easy to identify them quickly. 

@end itemize


@node Database schema details, Extensions schema, Database Overview, Database
@section @code{CVSAnalY} database schema details

@subsubheading The scmlog table

The main table is scmlog. Every commit in the repository is represented
by a record in the scmlog table. 

@itemize @bullet

@item
id: Identifier in the database.

@item
rev: It's the revision identifier in the repository. It's always unique
in every repository. 

@item
committer_id: Committer identifier, that is, the identifier in the
database of the person who did the commit.

@item
author_id: Author identifier. Some source control management systems,
differentiate the person who did the commit from the person who actually
made the changes. When not supported by the repository, this field will
be @code{NULL}.

@item
date: The date when the commit was done. 

@item
message: The commit message. 

@item
composed_rev: It's a boolean to indicate whether the rev field is
composed or not. This is needed because the rev field must be unique in
every repository which is not possible in CVS since it uses revision
numbers per file. The combination of a file path and its revision is
what make a commit unique in a system like CVS. For this particular case
the rev field is represented by the concatenation of the revision number, the
pipe character ('|') and the file path. Here is an example for a CVS
repository:

@example
1.1.2.1|/poppler/glib/demo/render.c
@end example

@item
repository_id: Identifier in the database of the repository where the
commit was done. 

@end itemize

@subsubheading The actions table

This table describes the different actions performed in every commit. In
systems like CVS, where the commit is limited to a single file, there
will be only one record in the actions table for every commit. However,
most of the version control systems support atomic commits, where
several actions are carried out on several files@footnote{With
@code{file} we actually refer to both file and directory}. 

@itemize @bullet

@item
id: Identifier in the database.

@item
type: It's a character representing the type of the action. Currently
supported actions are:

@itemize @bullet
@item
@code{'A'}: The file has been added to the repository. 
@item
@code{'M'}: The file has been modified. It's the most common action. 
@item
@code{'D'}: The files has been deleted. 
@item
@code{'V'}: The file has been renamed. This might be a simple rename or
that the file has been moved to another path keeping its name or not. In
any case, the file identifier will never change after a @code{'V'}
action.
@item
@code{'C'}: The file has been copied. It's similar to an @code{'A'}
action, since a new file is added to a repository, but in this case
it was copied from another existing file. 
@item
@code{'R'}: The file has been replaced. This means that an existing file
is removed, and a new one with the same name is added. In addition, another
existing file might be used as a base for the replacement, that is, the
new file is a copy of such an existing file. 
@end itemize

Not all of the action types are always supported, for example, for CVS
repositories only @code{'A'}, @code{'M'} and @code{'D'} actions are
supported. 

@item
commit_id: It's the identifier of the commit where the action was
performed. It's a foreign key that references the @code{id} field of
@code{scmlog} table.

@item
branch_id: It's the identifier of the branch where the action was
performed. It's a foreign key that references the @code{id} field of
@code{branches} table. 

@end itemize

@node Extensions schema, , Database schema details, Database
@section @code{CVSAnalY} extensions schema details


@node FAQ, GNU Free Documentation License, Database, Top
@chapter Frequently Asked Questions

@section Database

@subsection Why aren't branches associated to commits instead of actions?

While it's logical to think that a commit is always associated to a
single branch, that's not true in SVN repositories. The fact that
branches don't really exist in SVN (they are just paths in the
repository), makes possible to find commits involving files from different
branches for the same revision. It happens, indeed, more often
than expected. So, in most of the cases, all actions referencing the
same commit will reference the same branch too, but we need to keep the
relationship between action and branch in order to support all other cases. 

@raisesections
@include fdl.texi
@lowersections

@bye
