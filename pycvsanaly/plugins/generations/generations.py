import os
import Numeric
import string


"""
Data generated by this module can be displayied by using gnulplot:

% gnuplot
#set contour surface
#set palette gray
unset contour
set pm3d
unset surface
set ticslevel 0
set xlabel "Periods"
set ylabel "History (periods)"
set zlabel "Commits"
splot "matrix_top_commiters" with lines

It can be later output to a EPS file by:

set terminal postscript
set out "/tmp/draw.eps"
set view 36,41
splot "matrix_top_commiters" with lines
"""



class period:
    """
    Root class for kinds of periods.

    Initializes the template for producing a view of the database
    specific for a given kind of period (quarters, number of days, etc.)
    """
    
    def __init__(self):
        pass
    
    def name(self):
        pass
    
    def viewTemplate(self):
        pass
    
class periodQuarter (period):
    """
    Class for specifying quarters as kind of period
    """

    # SQL code for creating a view with the commits by commiter by period
    #  (being the period a quarter)
    #  The use of firstDate is for normalizing (first period will be 0)
    viewCreateTemplate = string.Template ("""
    create or replace
    view generations (period, commiter_id, commits)
    as select year(date_log)*4+quarter(date_log)-year("$firstDate")*4-quarter("$firstDate") as period, commiter_id, count(commit_id)
    from log
    where filetype = 5
    group by period, commiter_id
    order by period, count(date_log) desc;
    """)
    
    def __init__(self):
        pass
    
    def name(self):
        return "quarters"

    def viewTemplate(self):
        return self.viewCreateTemplate
    
class periodDays (period):
    """
    Class for specifying a number of days as kind of period
    """

    # SQL code for creating a view with the commits by commiter by period
    #  (being the period a number of days)
    #  The use of firstDate is for normalizing (first period will be 0)
    #  days is the number of days for each period
    viewCreateTemplateDays = string.Template ("""
    create or replace
    view generations (period, commiter_id, commits)
    as select (to_days(date_log) - to_days("$firstDate")) div $days as period, commiter_id, count(commit_id)
    from log
    where filetype = 5
    group by period, commiter_id
    order by period, count(date_log) desc;
    """)

    def __init__(self, days):
        self.days = days
        self.viewCreateTemplate = string.Template(
          self.viewCreateTemplateDays.safe_substitute (days=days))
        
    def name(self):
        return "days-" + str (self.days)
    
    def viewTemplate(self):
        return self.viewCreateTemplate

class periodSlots (period):
    """
    Class for specifying the number of slots (periods) as kind of period
    """

    # SQL code for creating a view with the commits by commiter by period
    #  (being the period a number of days)
    #  The use of firstDate is for normalizing (first period will be 0)
    #  days is the number of days for each period
    viewCreateTemplateSlots = string.Template ("""
    create or replace
    view generations (period, commiter_id, commits)
    as select (to_days(date_log) - to_days("$firstDate")) div ((to_days("$lastDate") - to_days("$firstDate")) div $slots) as period, commiter_id, count(commit_id)
    from log
    where filetype = 5
    group by period, commiter_id
    order by period, count(date_log) desc;
    """)

    def __init__(self, slots):
        self.slots = slots
        self.viewCreateTemplate = string.Template(
          self.viewCreateTemplateSlots.safe_substitute (slots=slots))
        
    def name(self):
        return "slots-" + str (self.slots)
    
    def viewTemplate(self):
        return self.viewCreateTemplate


class generations:

    connection = None

    def __init__(self, db, dirname, periodKind):
        # result = db.querySQLRaw ("select from_days((to_days(date_log) div 100)*100) as period, count(*) from log group by period")
        # result = db.querySQLRaw ("drop view generations")

        # Connection to the database
        self.connection = db
        # Directory to store results
        self.dirname = dirname + '/' + periodKind.name()

        # Dictionary with commits per period
        self.commitsPeriodDict = {}
        # Dictionary with commiters per period
        self.commitersPeriodDict = {}
        
        # Get earliest date from the log table
        result = self.connection.executeSQLRaw \
                 ("select min(date_log) from log;")
        self.firstDate = result[0][0]
        # Get latest date from the log table
        result = self.connection.executeSQLRaw \
                 ("select max(date_log) from log;")
        self.lastDate = result[0][0]
        # Produce SQL code for creating the view, based on the template
        viewCreateTemplate = periodKind.viewTemplate()
        viewCreate = viewCreateTemplate.substitute (firstDate=self.firstDate,
                                                    lastDate=self.lastDate)
        # FIXME
        # Next query produces no row, therefore an exception is raised
        # should be fixed (by improving the database interface)
        try:
            result = self.connection.executeSQLRaw (viewCreate)
        except:
            pass

        try:
            os.makedirs (self.dirname)
        except:
            print dirname + " already exists, not creating"

        # Generations database view, as an array of rows
        # Each row is period (starting at 0), commiter, commits.
        # Ordered by period, commits (descending)
        self.periodCommitsCommiter = \
          self.connection.executeSQLRaw ("select * from generations")
        self.lastPeriod = int (self.periodCommitsCommiter[-1][0])

        # Perform all the analysis
        print ('Performing analysis with period=' + periodKind.name())
        self.commitsPerPeriodPerCommiter()
        self.commitsPerPeriod()
        self.largestCommiters()
        self.topFractionCommits(0.1)
        self.topFractionCommits(0.5)
        self.topFractionCommits(1.0)
        self.topFractionCommiters(0.1)
        self.topFractionCommiters(0.2)
        self.topFractionCommiters(1.0)

    def commitsPerPeriodPerCommiter(self):

        """
        Print lines to a file, each line repesenting:
          period commiter commits
        """
        
        filehand = open(self.dirname + '/' + 'commits_per_period_per_commiter', 'w')
        
        result = self.connection.executeSQLRaw ("select * from generations")
        for row in result:
            # 0:period, 2:commiter, 3:commits
            filehand.write (row[0] + ' ' + row[1] + ' ' + row[2] + '\n')


    def commitsPerPeriod(self):

        """
        Print lines to a file, each line representing:
          period commits commiters
        Also, fills in self.commitsPeriodDict (commits per period)
        and self.commitersPeriodDict (commiters per period)
        """
        
        filehand = open(self.dirname + '/' + 'data_per_period', 'w')

        # Commits per period, as an array of rows
        commitsPeriod = \
          self.connection.executeSQLRaw \
          ("select period, sum(commits), count(commiter_id) \
          from generations group by period;")
        for row in commitsPeriod:
            # 0:period, 1:commits, 2: commiters
            filehand.write (row[0] + ' ' + row[1] + ' ' + row[2] + '\n') 
            self.commitsPeriodDict [int(row[0])] = int(row[1])
            self.commitersPeriodDict [int(row[0])] = int(row[2])

    def largestCommiters(self):

        """
        Get, for each period, the largest commiter, and trace her
        history (commits in any other period)
        """
        
        print ('- Generating matrix for largest commiters')
        file = self.dirname + '/' + 'matrix_top_commiters'

        matrixSize = self.lastPeriod + 1
        matrixPeriods = Numeric.zeros((matrixSize,matrixSize))
        currentPeriod = - 1
        for row in self.periodCommitsCommiter:
            # 0:period, 1:commiter, 2:commits
            period = int (row[0])
            if period > currentPeriod:
                # This row corresponds to the largest commiter in a new period
                currentPeriod = period
                commiter = row[1]
                self.commitsCommiterAllPeriods \
                  (commiter,
                   matrixPeriods[currentPeriod])
        # Now, write the matrix
        self.outputMatrix (matrixPeriods, file)

    def topFractionCommits(self, fraction):

        """
        Get, for each period, the commiters producing the top fraction
        of the commits, and trace their history (commits in any other
        period for all of them)

        fraction should be between 0 and 1
        """

        print ('- Generating matrix for commiters producing ' + \
              'top fraction of commits (fraction: ' + \
              str (fraction))
        file = self.dirname + '/' + 'matrix_top_fraction_commits-' + \
               str (fraction)

        matrixSize = self.lastPeriod + 1
        matrixPeriods = Numeric.zeros((matrixSize,matrixSize))
        currentPeriod = - 1
        for row in self.periodCommitsCommiter:
            # 0:period, 1:commiter, 2:commits
            period = int (row[0])
            commiter = row[1]
            if period > currentPeriod:
                # This row corresponds to a new period,
                #  init. values for new period
                currentPeriod = period
                currentCommits = 0
            if currentCommits < self.commitsPeriodDict[period] * fraction:
                # Still not all commiters wanted for this period,
                #   add this one
                currentCommits = currentCommits + int(row[2])
                self.commitsCommiterAllPeriods \
                  (commiter,
                   matrixPeriods[currentPeriod])
        # Now, write the matrix
        self.outputMatrix (matrixPeriods, file)

    def topFractionCommiters(self, fraction):

        """
        Get, for each period, the top fraction of commiters, and
        trace their history (commits in any other period for all
        of them)

        fraction should be between 0 and 1
        """
        
        print ('- Generating matrix for top fraction of commiters ' + \
               '(fraction: ' + \
               str (fraction) + ')')
        file = self.dirname + '/' + 'matrix_top_fraction_commiters-' + \
               str (fraction)

        matrixSize = self.lastPeriod + 1
        matrixPeriods = Numeric.zeros((matrixSize,matrixSize))
        currentPeriod = - 1
        for row in self.periodCommitsCommiter:
            # 0:period, 1:commiter, 2:commits
            period = int (row[0])
            commiter = row[1]
            if period > currentPeriod:
                # This row corresponds to a new period,
                #  init. values for new period
                currentPeriod = period
                currentCommiters = 0
            if currentCommiters < self.commitersPeriodDict[period] * fraction:
                # Still not all commiters wanted for this period,
                #   add this one
                currentCommiters = currentCommiters + 1
                self.commitsCommiterAllPeriods \
                  (commiter,
                   matrixPeriods[currentPeriod])
        # Now, write the matrix
        self.outputMatrix (matrixPeriods, file)


    def commitsCommiterAllPeriods(self, commiter, arrayCommits):

        """
        Calculate the number of commits per period, for all periods,
        for a given commiter, and produce an add that information
        to the given arrayCommits (which should be zeroed before
        calling this function in case this is the first call to fill
        it in).
        """
        
        # print arrayCommits
        result = self.connection.executeSQLRaw ("select period, sum(commits) from generations where commiter_id=" + str(commiter) + " group by period")
        for row in result:
            # 0:period, 1:commits
            period = int (row[0])
            arrayCommits [period] = arrayCommits [period] + int(row[1])

    def outputMatrix(self, matrix, file):

        """
        Matrix is two dimensional, with a value for each position.
        Output it to a file suitable for being shown by gnuplot.
        Both absolute and normalized (by the number of commits per period)
        matrices are produced.
        """

        filehand = open(file, 'w')

        for x in range(0, len(matrix)-1):
            for y in range(0, len(matrix[x])-1):
                filehand.write (str(x) + ' ' + str(y) + ' ' + str(matrix[x,y]) + '\n')
            filehand.write ('\n')

        filehand.close()

        filehand = open(file + '-normal', 'w')

        for x in range(0, len(matrix)-1):
            for y in range(0, len(matrix[x])-1):
                if y in self.commitsPeriodDict:
                    commitsNormalized = \
                      float (matrix[x,y]) / self.commitsPeriodDict[y]
                else:
                    commitsNormalized = 0
                filehand.write (str(x) + ' ' + str(y) + ' ' \
                                + str(commitsNormalized) \
                                + '\n')
            filehand.write ('\n')

        filehand.close()
